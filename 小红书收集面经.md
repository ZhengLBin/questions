## 2.cpp按值捕获和按引用捕获的区别？
这是C++中lambda表达式的一个重要概念，语法上，按值捕获是中括号中直接使用变量名，按引用捕获是通过取址符加上变量名捕获；按值捕获的话，它是创建变量的副本，占用额外内存，但访问速度快。它比较安全，即使原变量损毁也可正常使用，不可修改捕获的值，除非加上mutable；按引用捕获的话，只存储引用，内存开销小，但可能又间接访问开销，生命周期上有风险，如果原变量先于lambda损毁会导致悬空引用，它可以修改原变量。在嵌入式环境中，我通过有限考虑按值捕获来保证线程安全，只在确保生命周期安全的情况下使用按引用捕获来避免不必要的拷贝开销
## 3.malloc底层是怎么实现的？
程序运行时需要动态申请内存，但每次都调用系统调用太慢了（涉及用户态/内核态切换）。malloc就是解决这个问题，它先从操作系统要一大块内存，然后自己管理分配给程序。
比如第一次调用malloc(100)，它会向操作系统要一大块内存（比如64KB），然后划分成小块来管理，给程序分配100字节，剩下的备用。第二次调用malloc就不用找操作系统，直接从剩下的内存里分配。调用free就是把内存标记为空闲，下次malloc时可以重复使用。
底层实现：Linux下，通常以128KB为界，小块内存从预分配的堆中分配，大块内存直接调用mmap系统调用。每个内存块都有头部信息，记录块大小、前一块大小，空闲块还有链表指针。分配算法采用首次适应，释放时会合并相邻空闲块，并按大小分类存储（bins机制）加快查找。
嵌入式特殊处理：由于内存小且无虚拟内存保护，通常用内存池方式预分配固定大小块（如64B、256B、1KB），避免运行时的不确定性和碎片问题。
## 4.用户态如何获取内核态较大的数据，比如一个大的buffer数据？
传统方式是系统调用+数据拷贝，用户态通过系统调用获取，如read，但这样拷贝开销大；我们可以采用mmap内存映射的零拷贝方式（即用户态和内核态共享同一块物理内存），比如open某个设备路径之后，通过mmap将内核buffer映射到用户空间（前提是设备驱动实现了mmap接口），然后就可以直接访问内核数据。原理是将内核物理页面映射到用户虚拟地址空间，使得双方的虚拟地址指向同一块物理内存，避免了数据拷贝。这种方式特别适合视频、音频等大数据流的处理，能显著降低CPU占用和提高性能。
## 5.内存碎片有哪几种类型？
主要分为两大类型，一个是内部碎片，一个是外部碎片。内部碎片是分配给进程的内存块内部有未使用的空间，原因是内存对齐的要求，比如申请33字节，系统按64字节对齐分配，剩下的就是内部碎片。固定大小分配的内存池也会有这种情况。外部碎片是系统中有空闲内存，但都是不连续的小块，无法满足大的连续内存请求。内部碎片的主要应对方案是分级内存池，比如使用64B/256B/1024B三种池，外部碎片主要的应对方案是预分配策略，在启动时一次性分配所有需要的内存
## 7.项目中哪些模块使用了哪种总线协议？
根据我的项目经验，在电子香炉的温度传感器模块和显示模块我使用了I2C协议连接数字温度传感器和OLED显示屏，ESP32-S3的内置Flash通过SPI协议通信，模块间串行通信则使用UART协议进行调试和数据交互。在实际开发中，我主要根据不同应用场景选择合适的协议：I2C用于传感器等低速外设通信，具有设备地址寻址能力；SPI协议用于高速数据传输和Flash存储器访问；UART用于调试输出和点对点的模块间串行通信。
## 8.IIC
- IIC通信常见的速率有哪些？
```
1. 标准模式100kbit/s   
2. 快速模式400kbit/s   
3. 快速模式plus 1M bit/s
4. 高速模式 3.4M bit/s
```
- 简述IIC的工作原理。
``` 
IIC是一种两线式串行总线协议，使用SDA数据线和SCL时钟线两根线，
采用主从式通信架构，主机控制时钟信号，从机根据地址相应。
它支持多主机多从机挂载在同一总线上，通过设备地址进行寻址，
数据传输采用开漏输出配合上拉电阻，实现线与逻辑
```
- 一次完整的IIC传输信号包含哪些组成成分及其内容？
```
起始信号：当SCL为高电平时，SDA从高电平跳为低电平
设备地址：7位从机+1位读写控制位（0写1读）
应答信号（ACK）：从机拉低SDA表示应答（针对地址）
数据字节：8位数据，MSB先传输
应答信号(ACK/NACK):针对数据字节的应答
停止信号：SCL为高电平时，SDA从低电平跳为高电平
```

- IIC设备地址有多少位？/ 一条IIC总线上最多能挂载多少个设备？
```
一般使用7位设备地址，理论上可寻址128位，部分地址被保留用于特殊功能，实际可用约112个
```
- IIC电路设计上是否需要上拉电阻？

需要，IIC使用开漏输出，SDA和SCL都需要外接上拉电阻到VCC，典型阻值为4.7-10k欧姆，上拉电阻提供高电平驱动能力

- 开漏输出与推挽输出有何区别？
```
开漏输出：只能输出低电平，高电平依靠外部上拉电阻提供。支持线与逻辑，多设备可共享总线
推挽输出：既能输出高电平也能输出低电平，驱动能力强但多设备直接不能直接并联，会电流冲突
```
- 时序所需的延时是如何保证的

第一种方式是通过硬件IIC控制器，在config结构体中配置时钟频率，硬件自动保证时序；
第二种是通过软件实现模拟的延时函数；
在ESP32温控项目中，我主要使用硬件I2C与温度传感器通信，通过配置合适的时钟频率（100kHz标准速度），硬件控制器内部有专门的时序控制电路和状态机.根据配置的时钟频率，会自动计算各个时序参数，如SCL高低电平时间和数据建立保持时间等等

- 软件模拟IIC时，CPU因多次延时而被阻塞，中断服务程序可能导致这些延时发生滞后，这种滞后会对IIC的数据读取产生影响吗？

可能会导致时钟不稳定，中断使得每个时钟周期的持续时间不一致，导致IIC时钟频率波动，从机设备无法预测下个时钟沿的到来
还可能导致数据采样错误，超时问题，时钟占空比失调
可以使用硬件IIC或者通过在关键时序段关中断来解决，还可以提高任务优先级，减少被其他任务打断的可能；


- IIC的时钟信号SCL如果出现不均匀（占空比不一致或频率抖动），会对通信造成影响吗？

当占空比异常时，SCL低电平时间太短，SDA来不及在下一个上升沿之前稳定：从设备可能会在数据变化时采样导致采样错误；
频率不稳定的时候可能导致数据建立和保持时间错乱，比如第一个bit频率100khz建立时间充足，第二个bit变成300khz，建立时间不足。还可能导致从设备进入未知状态。
在实际应用中，当读数偶尔出现读取失败，或者ACK应答信号不稳定以及严重时总线死锁需要复位的情况下，可能是SCL不均匀导致的问题。

- IIC时序详解
```
起始条件：SCL高电平期间，SDA下降沿
数据有效：SCL高电平期间，SDA保持稳定
数据变化：SCL低电平期间，SDA可以变化
建立时间：数据在SCL上升沿之前的稳定时间
保持时间：数据在SCL下降沿后的保持时间
停止信号：SCL高电平期间，SDA上升沿
```
- IIC-tools调试工具
```
i2cdetect - 扫描I2C总线设备（最常用）
i2cdump - 读取设备所有寄存器
i2cget - 读取指定寄存器
i2cset - 写入指定寄存器
i2ctransfer - 执行原始I2C传输
```
## 9.FreeRTOS
- RTOS的基本运行机制是什么。
```
RTOS的基本运行机制包括任务调度、中断处理、时间管理和资源同步。
任务调度采用抢占式多任务，高优先级任务抢占低优先级任务，同优先级时间片轮转。
在我的温控项目中，温控任务优先级最高，能打断其他任务保证控制精度。
中断处理方面，RTOS提供FromISR版本的API配合信号量实现中断与任务的协作。
时间管理系统基于系统节拍，支持任务延时和超时等时间相关功能，常用的函数如xtaskdelay。
资源同步通过互斥锁等机制保护共享数据。
```
- 阐述FreeRTOS的任务调度原理。

FreeRTOS采用基于优先级的抢占式调度算法，结合时间片轮转机制实现多任务管理。
调度器的核心原理是通过就绪链表+优先级位图实现的，具体来说就是为每个优先级维护一个就绪任务链表，同时用优先级位图记录当前最高就绪优先级，这样调度器就能以O(1)的时间复杂度快速找到最高优先级的就绪任务。
任务状态在就绪、运行、阻塞、挂起四个基本状态中转换，当高优先级任务就绪时，立即抢占当前运行的低优先级任务，而相同优先级任务间根据时间片轮转机制进行调度。
任务切换时，底层首先保存当前任务的寄存器上下文到任务堆栈，然后调度器选择下一个要运行的任务并更新当前任务控制块指针，最后恢复新任务的寄存器上下文并跳转到对应的任务代码继续执行。

- 任务在系统中可能处于哪些运行状态，切换的时机是什么？
```
就绪、运行、阻塞、挂起四个基本状态
当发生被高优先级抢占或者时间片用完的时候，会从运行态切换到就绪态
当等待信号量或者主动延时的时候会从运行态切换到阻塞态
等待条件满足或者延时到期 从阻塞态恢复到就绪态
被调度器选择的时候 从就绪态切换为运行态
被其他任务挂起和恢复的时候，在运行态和挂起态之间切换
（任务切换时，底层首先保存当前任务的寄存器上下文到任务堆栈
然后调度器选择下一个要运行的任务并更新当前任务控制块指针，
最后恢复新任务的寄存器上下文并跳转到对应的任务代码继续执行。）
```
- 调度器何时进行任务切换。
```
1.系统节拍中断的时候检查是否需要调度，比如说延时到期引发的调度；
2.api函数触发调度使得任务主动让出CPU，比如
xtaskdelay，
xsemaphoretake，
xqueuereceive，
taskyield； 
中断服务程序唤醒高优先级任务以及其他改变任务状态的API调用时被触发；
```
- 什么是优先级反转？

优先级反转是指高优先级任务被低优先级任务间接阻塞，导致中优先级任务反而能够运行的异常现象。
具体发生机制是当低优先级任务获得互斥锁后，高优先级任务请求同一资源时被阻塞，此时如果中优先级任务抢占了低优先级任务，就会导致低优先级任务无法释放锁，从而使高优先级任务长时间等待，实际运行顺序变成中优先级>低优先级>高优先级的反转现象。
在应用中我们主要通过两种方案来解决：首先是使用优先级继承机制，通过创建xSemaphoreCreateMutex互斥锁，当高优先级任务被阻塞时系统自动将持有锁的低优先级任务临时提升到高优先级任务的优先级，避免被中优先级任务抢占；其次通过重新设计系统架构避免共享资源，比如使用消息队列代替共享变量；

- 互斥锁与信号量的区别是什么？
```
首先设计用途不同，互斥锁是保护共享资源的互斥访问，而信号量是用于任务同步和共享计数；
互斥锁有所有权，只能由获取锁的任务释放，而信号量，任何任务都可以give/take；
互斥锁支持优先级继承，可以防止优先级反转，而二进制信号量不支持优先级继承；
互斥锁不支持计数，计数型信号量可以计数；
在我的温控项目中，使用互斥锁保护温度数据结构，使用信号量进行按键事件和定时器事件的任务间同步
```
- 不同任务间如何进行数据交换或通信？
```
消息队列、信号量、互斥锁、事件组、任务通知
数据交换：首选消息队列，数据安全、无竞争(xQueueSend/xQueueReceive)
事件通知：使用信号量或任务通知(xSemaphoreGive/xSemaphoreTake)
共享资源：互斥锁+共享内存(xSemaphoreTake/xSemaphoreGive)
多事件等待：事件组(xEventGroupSetBits/xEventGroupWaitBits)
流式数据：流缓冲区(xStreamBufferReceive)
轻量通知：任务通知(vTaskNotifyGiveFromISR)
```
- 如何实现不同任务间的状态同步？
- 消息队列具备哪些特性？
- FreeRTOS是如何实现低功耗的？进入低功耗模式后如何被唤醒？
- 系统是如何/在何时感知到感到更高优先级的任务已经就绪可以运行了？（设计rtos底层的实现原理）
- 优先级模式有几种？优先级数值大小关系

## 10.解释堆和栈的概念
## 11.在裸机系统或RTOS环境下，有哪些高效且准确的方法可以确定一个任务或整个系统运行时栈的最大使用深度？如何在实际运行一段时间后检查栈的使用量
## 12.在哪些情况下栈的内容会发生改变？
## 13.CPU在进行现场保存（如函数嵌套调用,中断发生时）时，具体保存哪些信息？
## 14.当系统发生异常，例如进入hardfault时，如何定位问题的根源？
## 15.请描述MCU从通电启动到执行main函数的过程
## 16.介绍你项目中的串口使用方法，（涉及DMA，缓冲区，中断等）
## 17.当DMA传输全满中断和串口空闲中断的触发条件同时满足时，两者的中断标志位会同时置位并触发中断吗？
## 18.数组越界操作是否必然导致hardfault异常？如果不引发hardfault，可能会带来哪些其他不良后果
## 19.请介绍你实现低功耗的方法？若想从超低功耗的standby模式唤醒系统，应如何操作
## 20.半结构化
- 对本公司了解
- 行业现状和发展前景看待
- 近期职业发展规划
- 
## 21.当多个任务或线程需要并发访问同一个变量时，应如何处理以保证正确性？
## 22.说明条件变量的典型用法
## 23.哪些数据结构适合用来实现生产者，消费者模型，如何设计实现一个消息队列
## 24.你的项目中使用过哪些复杂的项目结构？
## 25.构造函数中深拷贝与浅拷贝的区别
## 26.智能指针，虚函数
## 27.是否使用过pthread库进行多线程编程
## 28.项目中应用了PID控制和外部中断，要求说明PID参数的初始化方法以及外部中断的具体应用场景
## 29.是否有过编译系统镜像和设备树的经验，如何操作
## 30.I2C是硬件实现还是软件模拟，原因是什么
## 31.了解uboot的启动流程
## 32.如何编写一个字符设备驱动
## 33.哪些场景下linux需要关闭中断
## 34.用数组实现链表功能
## 35.描述一个.c文件从编写到最终在开发板上运行的完整过程
## 36.解释逻辑地址 线性地址 物理地址
## 37.介绍linux的mmu
## 38.什么是嵌入式系统中的代码优化？
## 39.嵌入式系统中如何实现低延迟
## 40.解释usb协议
## 41.如何实现动态内存分配？
## 42.cmake和makefile区别
## 43.linux根文件系统（busybox uclibc buildroot yocto）
## 44.数组越界有什么危害
## 45.熟悉哪些操作系统
## 46.栈泄露有什么危害
## 47.GPIO推挽和开漏输出的区别
## 48.ad采样位数代表什么，什么因素影响ADC精度和转换速率，有什么滤波算法
## 49.中断如何设置 中断中任务过多有什么危害
## 50.串口通信起始位如何判定，IIC总线仲裁？
## 51.设备偶发重启如何定位？（分析崩溃现场寄存器，通过jlink读取cfsr，检测堆栈溢出，mpu区域配置；电源完整性测量，示波器抓取跌落波形）
## 52.IIC从机无响应如何排查（逻辑分析仪捕获SCL/SDA波形，验证上拉电阻阻值，通常4.7ko，检查从设备地址配置，7/10位）
## 53.手写spi驱动并解释时序参数配置
## 54.分析stm32启动过程，从bootloader到main的内存映射
## 55.解释dma双缓冲机制在音频采集或其他应用中的作用
## 56.字符设备驱动file_operation全解
## 57.uart通信如何保证数据的正确性
## 58.TCP协议中涉及的大端序和小端序问题
## 59.中断处理函数如果需要返回一个值，应如何实现？
## 60.平时如何进行技术学习？如何总结并汇报一个项目
## 61.TCP和UDP相关API函数
## 62.IIC总线的特点，速率范围，硬件IIC和软件模拟IIC的主要区别
## 63.spi工作原理
## 64.如何判断一个链表是否存在环
## 65.项目上主要遇到的技术难点
## 66.用过的stm32型号 他的主频
## 67.裸机和freertos的区别
## 68.freertos项目中建了几个task，优先级的还是定时任务
## 69.GDB常见命令和常用流程
## 70.RAII的核心概念和应用场景
## 71.设计模式，选择一个项目中用到的设计模式详细介绍
## 72.搞崩程序如何解决
## 73.介绍实习中的工作内容，遇到的技术方面的挑战
## 74.哪些功能遇到了多线程，开发过程中遇到的问题，合作经历，合作中遇到的问题 如何处理以及下一步改善
## 75.项目中某个技术的实现过程，优化达到的效果，指标体现
## 76.项目中有用不同的方案去对比吗 为什么选择这种方案
## 77.在嵌入式这个岗位中需要哪些核心能力 你自身有哪些和它匹配
## 78.C++
- C++特性 使用场景
- c++中的左值引用和指针的区别
- c++的内存分配机制是怎么样的
- mmu是什么 它如何将虚拟地址换为物理地址
- 智能指针理解
- 共享指针使用场景
- vector和list区别
- vector容器的底层实现机制以及优势所在
- vector扩容会按照什么数量级别进行扩容
- 扩容后访问vector下标容易造成迭代器的失效，怎么解决
- 对于vector这个对象，是放在堆上还是栈上
## 79.操作系统
- 进程间通讯方式
- 消息队列和共享内存详解
- 如何避免访问共享内存的时候出现操作不原子性的问题
- linux内存管理 当内存不够的时候 需要去申请内存 这时候系统会怎么做
## 80.说明flash rom ram和eeprom在嵌入式系统的不同应用场景
## 81.嵌入式系统中，信号处理函数通常采用哪些实现方式
## 82.于传统PID相比 现代控制算法如mpc 自适应控制有哪些优势，在嵌入式平台实现时要考虑哪些性能因素
## 83.设备树在嵌入式系统中有什么作用

