## 2.cpp按值捕获和按引用捕获的区别？
这是C++中lambda表达式的一个重要概念，语法上，按值捕获是中括号中直接使用变量名，按引用捕获是通过取址符加上变量名捕获；按值捕获的话，它是创建变量的副本，占用额外内存，但访问速度快。它比较安全，即使原变量损毁也可正常使用，不可修改捕获的值，除非加上mutable；按引用捕获的话，只存储引用，内存开销小，但可能又间接访问开销，生命周期上有风险，如果原变量先于lambda损毁会导致悬空引用，它可以修改原变量。在嵌入式环境中，我通过有限考虑按值捕获来保证线程安全，只在确保生命周期安全的情况下使用按引用捕获来避免不必要的拷贝开销
## 3.malloc底层是怎么实现的？
程序运行时需要动态申请内存，但每次都调用系统调用太慢了（涉及用户态/内核态切换）。malloc就是解决这个问题，它先从操作系统要一大块内存，然后自己管理分配给程序。
比如第一次调用malloc(100)，它会向操作系统要一大块内存（比如64KB），然后划分成小块来管理，给程序分配100字节，剩下的备用。第二次调用malloc就不用找操作系统，直接从剩下的内存里分配。调用free就是把内存标记为空闲，下次malloc时可以重复使用。
底层实现：Linux下，通常以128KB为界，小块内存从预分配的堆中分配，大块内存直接调用mmap系统调用。每个内存块都有头部信息，记录块大小、前一块大小，空闲块还有链表指针。分配算法采用首次适应，释放时会合并相邻空闲块，并按大小分类存储（bins机制）加快查找。
嵌入式特殊处理：由于内存小且无虚拟内存保护，通常用内存池方式预分配固定大小块（如64B、256B、1KB），避免运行时的不确定性和碎片问题。
## 4.用户态如何获取内核态较大的数据，比如一个大的buffer数据？
传统方式是系统调用+数据拷贝，用户态通过系统调用获取，如read，但这样拷贝开销大；我们可以采用mmap内存映射的零拷贝方式（即用户态和内核态共享同一块物理内存），比如open某个设备路径之后，通过mmap将内核buffer映射到用户空间（前提是设备驱动实现了mmap接口），然后就可以直接访问内核数据。原理是将内核物理页面映射到用户虚拟地址空间，使得双方的虚拟地址指向同一块物理内存，避免了数据拷贝。这种方式特别适合视频、音频等大数据流的处理，能显著降低CPU占用和提高性能。
## 5.内存碎片有哪几种类型？
主要分为两大类型，一个是内部碎片，一个是外部碎片。内部碎片是分配给进程的内存块内部有未使用的空间，原因是内存对齐的要求，比如申请33字节，系统按64字节对齐分配，剩下的就是内部碎片。固定大小分配的内存池也会有这种情况。外部碎片是系统中有空闲内存，但都是不连续的小块，无法满足大的连续内存请求。内部碎片的主要应对方案是分级内存池，比如使用64B/256B/1024B三种池，外部碎片主要的应对方案是预分配策略，在启动时一次性分配所有需要的内存
## 7.项目中哪些模块使用了哪种总线协议？
根据我的项目经验，在电子香炉的温度传感器模块和显示模块我使用了I2C协议连接数字温度传感器和OLED显示屏，ESP32-S3的内置Flash通过SPI协议通信，模块间串行通信则使用UART协议进行调试和数据交互。在实际开发中，我主要根据不同应用场景选择合适的协议：I2C用于传感器等低速外设通信，具有设备地址寻址能力；SPI协议用于高速数据传输和Flash存储器访问；UART用于调试输出和点对点的模块间串行通信。
## 8.IIC
- IIC通信常见的速率有哪些？
```
1. 标准模式100kbit/s   
2. 快速模式400kbit/s   
3. 快速模式plus 1M bit/s
4. 高速模式 3.4M bit/s
```
- 简述IIC的工作原理。
``` 
IIC是一种两线式串行总线协议，使用SDA数据线和SCL时钟线两根线，
采用主从式通信架构，主机控制时钟信号，从机根据地址相应。
它支持多主机多从机挂载在同一总线上，通过设备地址进行寻址，
数据传输采用开漏输出配合上拉电阻，实现线与逻辑
```
- 一次完整的IIC传输信号包含哪些组成成分及其内容？
```
起始信号：当SCL为高电平时，SDA从高电平跳为低电平
设备地址：7位从机+1位读写控制位（0写1读）
应答信号（ACK）：从机拉低SDA表示应答（针对地址）
数据字节：8位数据，MSB先传输
应答信号(ACK/NACK):针对数据字节的应答
停止信号：SCL为高电平时，SDA从低电平跳为高电平
```

- IIC设备地址有多少位？/ 一条IIC总线上最多能挂载多少个设备？
```
一般使用7位设备地址，理论上可寻址128位，部分地址被保留用于特殊功能，实际可用约112个
```
- IIC电路设计上是否需要上拉电阻？

需要，IIC使用开漏输出，SDA和SCL都需要外接上拉电阻到VCC，典型阻值为4.7-10k欧姆，上拉电阻提供高电平驱动能力

- 开漏输出与推挽输出有何区别？
```
开漏输出：只能输出低电平，高电平依靠外部上拉电阻提供。支持线与逻辑，多设备可共享总线
推挽输出：既能输出高电平也能输出低电平，驱动能力强但多设备直接不能直接并联，会电流冲突
```
- 时序所需的延时是如何保证的

第一种方式是通过硬件IIC控制器，在config结构体中配置时钟频率，硬件自动保证时序；
第二种是通过软件实现模拟的延时函数；
在ESP32温控项目中，我主要使用硬件I2C与温度传感器通信，通过配置合适的时钟频率（100kHz标准速度），硬件控制器内部有专门的时序控制电路和状态机.根据配置的时钟频率，会自动计算各个时序参数，如SCL高低电平时间和数据建立保持时间等等

- 软件模拟IIC时，CPU因多次延时而被阻塞，中断服务程序可能导致这些延时发生滞后，这种滞后会对IIC的数据读取产生影响吗？

可能会导致时钟不稳定，中断使得每个时钟周期的持续时间不一致，导致IIC时钟频率波动，从机设备无法预测下个时钟沿的到来
还可能导致数据采样错误，超时问题，时钟占空比失调
可以使用硬件IIC或者通过在关键时序段关中断来解决，还可以提高任务优先级，减少被其他任务打断的可能；


- IIC的时钟信号SCL如果出现不均匀（占空比不一致或频率抖动），会对通信造成影响吗？

当占空比异常时，SCL低电平时间太短，SDA来不及在下一个上升沿之前稳定：从设备可能会在数据变化时采样导致采样错误；
频率不稳定的时候可能导致数据建立和保持时间错乱，比如第一个bit频率100khz建立时间充足，第二个bit变成300khz，建立时间不足。还可能导致从设备进入未知状态。
在实际应用中，当读数偶尔出现读取失败，或者ACK应答信号不稳定以及严重时总线死锁需要复位的情况下，可能是SCL不均匀导致的问题。

- IIC时序详解
```
起始条件：SCL高电平期间，SDA下降沿
数据有效：SCL高电平期间，SDA保持稳定
数据变化：SCL低电平期间，SDA可以变化
建立时间：数据在SCL上升沿之前的稳定时间
保持时间：数据在SCL下降沿后的保持时间
停止信号：SCL高电平期间，SDA上升沿
```
- IIC-tools调试工具
```
i2cdetect - 扫描I2C总线设备（最常用）
i2cdump - 读取设备所有寄存器
i2cget - 读取指定寄存器
i2cset - 写入指定寄存器
i2ctransfer - 执行原始I2C传输
```
## 9.FreeRTOS
- RTOS的基本运行机制是什么。
```
RTOS的基本运行机制包括任务调度、中断处理、时间管理和资源同步。
任务调度采用抢占式多任务，高优先级任务抢占低优先级任务，同优先级时间片轮转。
在我的温控项目中，温控任务优先级最高，能打断其他任务保证控制精度。
中断处理方面，RTOS提供FromISR版本的API配合信号量实现中断与任务的协作。
时间管理系统基于系统节拍，支持任务延时和超时等时间相关功能，常用的函数如xtaskdelay。
资源同步通过互斥锁等机制保护共享数据。
```
- 阐述FreeRTOS的任务调度原理。

FreeRTOS采用基于优先级的抢占式调度算法，结合时间片轮转机制实现多任务管理。
调度器的核心原理是通过就绪链表+优先级位图实现的，具体来说就是为每个优先级维护一个就绪任务链表，同时用优先级位图记录当前最高就绪优先级，这样调度器就能以O(1)的时间复杂度快速找到最高优先级的就绪任务。
任务状态在就绪、运行、阻塞、挂起四个基本状态中转换，当高优先级任务就绪时，立即抢占当前运行的低优先级任务，而相同优先级任务间根据时间片轮转机制进行调度。
任务切换时，底层首先保存当前任务的寄存器上下文到任务堆栈，然后调度器选择下一个要运行的任务并更新当前任务控制块指针，最后恢复新任务的寄存器上下文并跳转到对应的任务代码继续执行。

- 任务在系统中可能处于哪些运行状态，切换的时机是什么？
```
就绪、运行、阻塞、挂起四个基本状态
当发生被高优先级抢占或者时间片用完的时候，会从运行态切换到就绪态
当等待信号量或者主动延时的时候会从运行态切换到阻塞态
等待条件满足或者延时到期 从阻塞态恢复到就绪态
被调度器选择的时候 从就绪态切换为运行态
被其他任务挂起和恢复的时候，在运行态和挂起态之间切换
（任务切换时，底层首先保存当前任务的寄存器上下文到任务堆栈
然后调度器选择下一个要运行的任务并更新当前任务控制块指针，
最后恢复新任务的寄存器上下文并跳转到对应的任务代码继续执行。）
```
- 调度器何时进行任务切换。
```
1.系统节拍中断的时候检查是否需要调度，比如说延时到期引发的调度；
2.api函数触发调度使得任务主动让出CPU，比如
xtaskdelay，
xsemaphoretake，
xqueuereceive，
taskyield； 
中断服务程序唤醒高优先级任务以及其他改变任务状态的API调用时被触发；
```
- 什么是优先级反转？

优先级反转是指高优先级任务被低优先级任务间接阻塞，导致中优先级任务反而能够运行的异常现象。
具体发生机制是当低优先级任务获得互斥锁后，高优先级任务请求同一资源时被阻塞，此时如果中优先级任务抢占了低优先级任务，就会导致低优先级任务无法释放锁，从而使高优先级任务长时间等待，实际运行顺序变成中优先级>低优先级>高优先级的反转现象。
在应用中我们主要通过两种方案来解决：首先是使用优先级继承机制，通过创建xSemaphoreCreateMutex互斥锁，当高优先级任务被阻塞时系统自动将持有锁的低优先级任务临时提升到高优先级任务的优先级，避免被中优先级任务抢占；其次通过重新设计系统架构避免共享资源，比如使用消息队列代替共享变量；

- 互斥锁与信号量的区别是什么？
```
首先设计用途不同，互斥锁是保护共享资源的互斥访问，而信号量是用于任务同步和共享计数；
互斥锁有所有权，只能由获取锁的任务释放，而信号量，任何任务都可以give/take；
互斥锁支持优先级继承，可以防止优先级反转，而二进制信号量不支持优先级继承；
互斥锁不支持计数，计数型信号量可以计数；
在我的温控项目中，使用互斥锁保护温度数据结构，使用信号量进行按键事件和定时器事件的任务间同步
```
- 不同任务间如何进行数据交换或通信？
```
消息队列、信号量、互斥锁、事件组、任务通知
数据交换：首选消息队列，数据安全、无竞争(xQueueSend/xQueueReceive)
事件通知：使用信号量或任务通知(xSemaphoreGive/xSemaphoreTake)
共享资源：互斥锁+共享内存(xSemaphoreTake/xSemaphoreGive)
多事件等待：事件组(xEventGroupSetBits/xEventGroupWaitBits)
流式数据：流缓冲区(xStreamBufferReceive)
轻量通知：任务通知(vTaskNotifyGiveFromISR)
```
- 如何实现不同任务间的状态同步？
```
1. 二进制信号量（Binary Semaphore）
- 任务间事件通知，类似于事件标志
- 用于简单的同步等待

2. 计数信号量（Counting Semaphore）
- 资源计数管理，如限制同时访问某资源的任务数量
- 生产者-消费者模式

3. 互斥量（Mutex）
- 保护共享资源，防止竞态条件
- 支持优先级继承，避免优先级反转

4. 队列（Queue）
- 任务间数据传递
- 天然具备同步功能，空队列时接收任务阻塞

5. 事件组（Event Groups）
- 多个事件位的组合同步
- 等待多个条件同时满足或满足其中一个

6. 任务通知（Task Notifications）
- 轻量级同步机制，每个任务都有内置通知值
- 性能比信号量更高
```
- 消息队列具备哪些特性？
```
FIFO机制：先进先出，保证消息顺序
阻塞特性：队列满时发送阻塞，队列空时接收阻塞
原子操作：入队出队操作不可分割，线程安全
拷贝语义：传递的是数据副本，不是指针
容量控制：创建时指定队列长度和消息大小
超时机制：支持阻塞超时设置
```
- FreeRTOS是如何实现低功耗的？进入低功耗模式后如何被唤醒？

- 系统是如何/在何时感知到感到更高优先级的任务已经就绪可以运行了？（设计rtos底层的实现原理）
```
底层实现原理：
就绪链表：每个优先级维护一个就绪任务链表
优先级位图：用位图记录哪些优先级有就绪任务
调度时机：
系统调用返回时检查
中断服务程序返回时检查
任务主动让出CPU时检查

感知过程：
// 任务变为就绪时
- 将任务加入对应优先级就绪链表
- 设置优先级位图对应位
- 如果优先级高于当前运行任务，触发任务切换
```
- 优先级模式有几种？优先级数值大小关系
```
优先级模式：

抢占式调度：高优先级立即抢占低优先级
时间片轮转：同优先级任务轮流执行
合作式调度：任务主动让出CPU才切换
数值关系：
FreeRTOS：数值越大优先级越高（0最低）
FreeRTOS中，configMAX_PRIORITIES定义最大优先级数，通常设置为5-32。在我的项目中，温控任务设为最高优先级确保实时响应。
```

## 10.解释堆和栈的概念
```
栈（Stack）：

分配方式：自动分配，编译时确定大小
存储结构：LIFO（后进先出），连续内存空间
存储内容：局部变量、函数参数、返回地址、寄存器备份
访问速度：快，直接通过栈指针访问
生命周期：随作用域自动管理
大小限制：通常较小（KB级），栈溢出风险

堆（Heap）：

分配方式：手动分配释放（malloc/free）
存储结构：随机访问，内存碎片化
存储内容：动态分配的数据结构
访问速度：慢，需要通过指针间接访问
生命周期：程序员手动管理
大小限制：较大，受系统内存限制

嵌入式中的区别：

栈通常在SRAM中，堆可能在外部DRAM
嵌入式系统栈空间有限，需要特别注意栈溢出
```
## 11.在哪些情况下栈的内容会发生改变？
```
函数调用相关：
函数调用：压入返回地址、参数、局部变量
函数返回：弹出局部变量、恢复返回地址
递归调用：每层递归都会压栈新的栈帧

中断处理：
中断发生：自动保存当前程序状态（PC、寄存器）
中断返回：恢复中断前的程序状态
中断嵌套：多层中断会多次压栈

任务切换（RTOS环境）：
任务调度：保存当前任务上下文到栈
任务恢复：从栈中恢复任务上下文
每个任务有独立栈空间

异常处理：
异常发生：保存异常现场信息
异常恢复：恢复或跳转到异常处理程序

编译器优化：
寄存器溢出：寄存器不够用时，变量溢出到栈

```
## 12.在裸机系统或RTOS环境下，有哪些高效且准确的方法可以确定一个任务或整个系统运行时栈的最大使用深度？如何在实际运行一段时间后检查栈的使用量
```
静态分析方法

编译器工具：使用GCC的-fstack-usage选项，编译时生成每个函数的栈使用分析报告
链接器分析：查看.map文件分析调用关系，计算理论最大栈深度

动态检测方法

栈填充法：系统启动时用特定模式（如0xDEADBEEF）填充整个栈空间，运行一段时间后检查哪些区域被覆盖，未被覆盖的就是未使用的栈空间
栈指针监控：定期记录栈指针的最小值，计算与栈顶的差值就是最大使用深度

RTOS环境
FreeRTOS提供了uxTaskGetStackHighWaterMark()API，返回任务栈的最小剩余空间。我在ESP32-S3项目中定期调用这个函数监控各任务栈使用情况，当剩余空间小于阈值时发出警告。
```
## 13.CPU在进行现场保存（如函数嵌套调用,中断发生时）时，具体保存哪些信息？
```
函数嵌套调用时保存的信息
必须保存的核心信息：

返回地址（PC）：函数执行完后返回到哪里继续执行
函数参数：传递给被调用函数的参数值
局部变量：当前函数的局部变量数据
寄存器状态：根据调用约定，保存调用者使用的寄存器

保存位置：主要在栈中，按照栈帧结构组织

中断发生时保存的信息
硬件自动保存（以ARM Cortex-M为例）：

程序计数器（PC）：中断发生时的指令地址
程序状态寄存器（PSR）：标志位、中断掩码等状态
返回地址（LR）：中断返回地址
工作寄存器（r0-r3, r12）：参数和临时寄存器

软件可能需要保存：
其他通用寄存器（r4-r11）：如果中断服务程序要使用
浮点寄存器：如果中断中有浮点运算
专用寄存器：特定外设的控制寄存器
```
## 14.当系统发生异常，例如进入hardfault时，如何定位问题的根源？
```
什么是HardFault
HardFault是ARM Cortex-M系列处理器中最高优先级的系统异常，当处理器遇到无法处理的错误时会触发。它本质上是一个"兜底"异常处理机制，当其他具体的fault异常（如MemManage、BusFault、UsageFault）被禁用或无法处理时，系统就会进入HardFault。
HardFault的常见触发原因

内存访问错误
访问无效内存地址（野指针、空指针解引用）
栈溢出导致访问非法地址
数组越界访问

指令执行错误
跳转到无效地址执行代码
执行未定义指令
ARM/Thumb指令集切换错误

总线访问故障
访问不存在的外设寄存器
在外设时钟未使能时访问寄存器

定位方法：
1. 使用调试器查看Call Stack（调用栈窗口），有的调试器双击可以跳转到出错的代码行，当定位到出错函数后，在调试器的"Watch"窗口查看检查具体变量值
2. 在异常处理函数里点亮不同的LED来区分错误类型
3. 在串口打印调试信息
```
## 15.请描述MCU从通电启动到执行main函数的过程
第一步是硬件复位，MCU通电后会自动启动内部时钟，同时将所有寄存器复位到默认值。

第二步是读取向量表，MCU会从Flash起始地址读取栈顶指针和复位向量，程序计数器PC就指向了Reset_Handler函数。

第三步执行Reset_Handler，这是一段汇编代码，主要做三件事：设置栈指针、调用SystemInit进行系统初始化、最后跳转到main函数。

第四步SystemInit函数会配置系统时钟，这样CPU就能以最高频率运行。

第五步是C运行环境准备，包括将已初始化的全局变量从Flash拷贝到RAM，把未初始化的全局变量清零。
最后才跳转到main函数开始执行用户代码。整个过程在我的ESP32项目中大约需要几百毫秒。
## 17.当DMA传输全满中断和串口空闲中断的触发条件同时满足时，两者的中断标志位会同时置位并触发中断吗？
```
会同时置位并触发中断的。
中断标志位是独立的，DMA传输完成和串口空闲检测是两个独立的硬件事件，所以它们的标志位会各自置位。
关键在于中断优先级，NVIC会根据我们设置的优先级来决定哪个中断先执行。比如我设置DMA中断优先级为1，串口中断优先级为2，那么会先处理DMA中断，完成后再处理串口中断。
两个中断都不会丢失，这点很重要。即使低优先级的中断被高优先级打断，等高优先级处理完成后，低优先级中断仍然会继续执行。
```
## 18.数组越界操作是否必然导致hardfault异常？如果不引发hardfault，可能会带来哪些其他不良后果
```
数组越界不一定导致HardFault，这取决于越界访问的内存位置。
不引发HardFault的情况比如越界但仍在RAM的有效区域内，或者访问到了栈空间，这时程序不会崩溃但会破坏其他数据。
引发HardFault的情况是当越界访问到了非法内存区域，比如访问了未映射的地址空间。
其他不良后果其实更危险，因为程序表面上还在正常运行：
数据损坏是最常见的，比如数组越界可能覆盖了相邻变量的数据，导致程序逻辑错误但很难发现。
栈破坏可能覆盖函数的返回地址，导致函数返回时跳转到错误位置，程序就跑飞了。
我现在会加边界检查，使用安全的字符串函数，开启编译器的栈保护选项来预防这类问题。
```
## 21.当多个任务或线程需要并发访问同一个变量时，应如何处理以保证正确性？
```
主要的保护机制：
互斥量（Mutex）保护 - 这是最常用的方法，确保同一时间只有一个任务能访问共享变量。任务在访问前获取互斥量，访问完后释放。
信号量机制 - 二进制信号量类似互斥量，计数信号量可以控制同时访问的任务数量。
关中断保护 - 在嵌入式系统中，对于简单的共享变量访问，可以临时关闭中断来形成临界区，这是最快速的保护方式。
原子操作 - 对于简单的数值操作，使用硬件支持的原子指令，比如原子加减、原子交换等，效率最高。
选择策略：
在我的项目经验中，对于简单的标志位或计数器，我优先使用关中断；对于复杂的数据结构操作，使用互斥量；对于性能要求很高的场合，使用原子操作。
重要原则：临界区代码要尽可能短，避免在临界区内调用可能阻塞的函数。
```
## 22.说明条件变量的典型用法
```
条件变量用于让线程等待某个特定条件成立，它必须和互斥量配合使用。
典型使用场景：
等待资源可用 - 比如等待缓冲区有空间或有数据，线程会阻塞等待直到条件满足。
任务同步 - 比如主任务等待多个子任务完成后再继续执行。
状态变化通知 - 当系统状态发生变化时，通知等待的线程。
基本使用模式：
等待方：先获取互斥量，然后在while循环中检查条件，条件不满足就调用条件变量的等待函数，等待时会自动释放互斥量并阻塞。
通知方：先获取互斥量，修改共享状态，然后发送条件变量信号唤醒等待的线程。
```
## 23.哪些数据结构适合用来实现生产者，消费者模型，如何设计实现一个消息队列
```
适合的数据结构：
环形缓冲区（Ring Buffer） - 这是最经典的选择，使用数组实现，有头尾指针，空间利用率高，访问效率好。
链表队列 - 动态分配内存，长度可变，但在嵌入式系统中可能有内存碎片问题。
数组队列 - 固定大小的数组，实现简单，适合嵌入式系统。
消息队列的设计要点：
数据结构选择 - 我推荐环形缓冲区，因为它避免了频繁的内存分配释放，性能稳定。
同步机制 - 需要两个信号量，一个表示空闲空间数量，一个表示已用空间数量，还需要一个互斥量保护队列操作。
边界处理 - 队列满时生产者的处理策略：可以阻塞等待、丢弃新数据、或者覆盖旧数据，根据应用需求选择。
线程安全 - 读写指针的更新要保证原子性，避免出现数据竞争。
在我的项目实践中：
温控项目用环形缓冲区存储温度采样数据，采集任务作为生产者，控制算法作为消费者。
摄像头项目用消息队列传递帧数据指针，避免大数据的拷贝，只传递指针和元数据。
```
## 25.构造函数中深拷贝与浅拷贝的区别
```
浅拷贝的问题：
浅拷贝只复制指针的值，不复制指针指向的内容。这就像两个人拿着同一把钥匙开同一扇门，一个人把门锁了，另一个人就进不去了。
典型问题场景：如果类中有指针成员，默认的拷贝构造函数只会复制指针地址，两个对象就会指向同一块内存。当其中一个对象析构时释放了这块内存，另一个对象再访问就会出现野指针问题。
深拷贝的解决方案：
深拷贝会为新对象重新分配内存空间，复制原始数据的内容。就像给每个人都配一把自己的钥匙和自己的门。
实现要点：在拷贝构造函数中，如果发现有指针成员，就用new申请新的内存空间，然后把原始数据复制过去。
关键原则：如果类中有动态分配的内存、文件句柄、网络连接等资源，一定要实现深拷贝，遵循"三五法则"。
```
## 26.智能指针，虚函数
```
智能指针的作用：
自动内存管理，最大的好处是不用手动delete，智能指针会在合适的时候自动释放内存，避免内存泄漏。
主要类型：shared_ptr支持多个指针共享同一对象，引用计数为0时自动释放；unique_ptr独占所有权，不能复制只能移动；weak_ptr解决shared_ptr的循环引用问题。
使用经验：在我的项目中，对于单一所有权的场景用unique_ptr，对于需要共享的资源用shared_ptr，比如多个线程共享同一个配置对象。
虚函数的机制：
实现多态的基础，通过虚函数表实现动态绑定。基类指针可以调用派生类的重写函数，实现"一个接口，多种实现"。
虚函数表：每个包含虚函数的类都有一个虚函数表，对象创建时会包含一个指向虚函数表的指针。
性能考虑：虚函数调用比普通函数调用稍慢，因为需要通过虚函数表间接调用，但这种开销通常是可以接受的。
使用场景：当需要通过基类接口操作不同派生类对象时，比如图形界面中不同控件都继承自基类Control，但每个控件的绘制方法不同。
```
## 27.是否使用过pthread库进行多线程编程
```
pthread更适合Linux环境，API更丰富，但资源开销也更大。
常用功能：
线程创建和管理：使用pthread_create创建线程，pthread_join等待线程结束，pthread_detach设置线程分离状态。
同步机制：pthread_mutex_t实现互斥锁，pthread_cond_t实现条件变量，pthread_rwlock_t实现读写锁。
线程属性设置：通过pthread_attr_t设置线程栈大小、调度策略、优先级等属性。
项目实践经验：
在摄像头项目中，用pthread创建了采集线程、处理线程和传输线程，通过pthread_mutex保护共享的帧缓冲区，用pthread_cond实现线程间的同步通信。
遇到的问题和解决：曾经遇到过死锁问题，是因为锁的获取顺序不一致导致的，后来统一了锁的获取顺序就解决了。还遇到过线程栈溢出，通过pthread_attr_setstacksize增大栈空间解决。
```


## 31.了解uboot的启动流程
```
U-Boot的启动分为两个主要阶段：
第一阶段（汇编代码）：CPU复位后首先执行，主要做最基础的硬件初始化。包括关闭看门狗、设置CPU模式、初始化内存控制器、代码重定位等。这个阶段代码很精简，因为此时DDR内存可能还不可用。
第二阶段（C代码）：跳转到C语言的main函数执行，这时候内存已经可用了。主要完成外设初始化、环境变量设置、启动菜单显示等。
具体启动流程：
硬件初始化：配置时钟、初始化DDR内存控制器、设置GPIO等基础硬件。
代码重定位：将U-Boot代码从Flash拷贝到DDR内存中运行，提高执行效率。
环境变量加载：从Flash中读取保存的环境变量，这些变量控制系统的启动行为。
启动内核：根据bootcmd环境变量的设置，从指定位置加载Linux内核和设备树，然后跳转到内核执行。
在我的项目经验中：
在RK1126项目里，需要修改U-Boot来适配我们的硬件，主要是修改设备树配置和添加自定义的初始化代码。U-Boot的灵活性让我们可以通过环境变量轻松切换不同的启动方式。
```
## 32.如何编写一个字符设备驱动
```
字符设备驱动的基本框架：
核心是file_operations结构体，定义设备的操作接口，包括open、read、write、close等函数指针，这些函数对应用户空间程序调用相应系统调用时的处理逻辑。
设备注册：通过register_chrdev或者更现代的cdev_add方式向内核注册字符设备，分配主设备号和次设备号。
内存管理：驱动中经常需要在内核空间和用户空间之间传递数据，要使用copy_to_user和copy_from_user这样的安全接口。
编写步骤：
第一步定义设备结构体，包含设备的私有数据、缓冲区、同步对象等。
第二步实现操作函数，比如open函数中做设备初始化，read/write函数处理数据传输，release函数做清理工作。
第三步模块初始化和卸载，在init函数中注册设备、申请资源，在exit函数中释放资源、注销设备。
关键注意点：
并发控制：多个进程可能同时访问设备，需要用mutex、spinlock等同步机制保护共享资源。
中断处理：如果设备需要中断支持，要实现中断处理函数，通过request_irq注册中断处理程序。
内存分配：在内核中使用kmalloc而不是malloc，注意GFP标志的选择。
我的实践经验：
虽然我主要做应用层开发，但在调试硬件接口时也接触过简单的字符设备驱动，主要是GPIO控制和串口通信相关的。理解驱动原理对于嵌入式开发很重要，有助于更好地理解硬件和软件的接口。
```
## 33.哪些场景下linux需要关闭中断
```
主要使用场景：
保护临界区：当内核代码需要访问共享数据结构时，关闭中断可以防止中断处理程序打断，这是最基础的同步机制。
原子操作保证：某些操作必须是原子的，比如修改重要的内核数据结构，关闭中断确保操作不被中断。
硬件寄存器操作：访问某些敏感的硬件寄存器时，需要关闭中断避免操作被打断导致硬件状态不一致。
使用原则：
尽可能短：关闭中断的时间要尽可能短，因为这会影响系统的实时性。
不能嵌套：在已经关闭中断的代码中不要再调用可能关闭中断的函数。
```
## 34.用数组实现链表功能
```
基本思想：
用数组下标代替指针，每个数组元素包含数据和下一个节点的下标，这样就能模拟链表的链接关系。
数据结构设计：
节点结构：每个数组元素包含两部分，一是存储的数据，二是next字段存储下一个节点在数组中的下标。
管理信息：需要维护一个头节点下标、一个空闲链表头下标，用于管理哪些位置是空闲的。
核心操作实现：
插入操作：从空闲链表中取一个空闲节点，填入数据，然后修改前一个节点的next字段指向这个新节点。
删除操作：修改前一个节点的next字段跳过要删除的节点，然后把被删除的节点加入空闲链表。
遍历操作：从头节点开始，通过next字段不断跳转到下一个节点，直到遇到结束标记。
优势和应用场景：
内存局部性好：相比真正的链表，数组实现的链表在cache友好性方面更好，访问效率更高。
内存管理简单：不需要动态分配内存，避免了内存碎片问题，特别适合嵌入式系统。
调试方便：可以直接查看整个数组的内容，便于调试和内存监控。
```
## 35.描述一个.c文件从编写到最终在开发板上运行的完整过程
```
源码编写阶段：
编写.c源文件和.h头文件，包含程序逻辑、硬件配置、库函数调用等。同时要准备Makefile或者使用IDE的工程配置。
编译过程的四个步骤：
预处理：处理#include、#define等预处理指令，展开宏定义，生成.i文件。这个阶段主要是文本替换工作。
编译：将预处理后的.i文件编译成汇编代码.s文件，这个过程包含语法检查、语义分析、代码优化等。
汇编：将汇编代码.s文件转换成机器码目标文件.o，这时已经是二进制代码了，但还没有链接。
链接：将多个.o目标文件和库文件链接成最终的可执行文件，解决符号引用，分配最终的内存地址。
交叉编译工具链：
使用交叉编译器：比如arm-linux-gnueabihf-gcc，因为开发机和目标板的架构不同，需要交叉编译工具链。
指定目标架构：编译时要指定目标CPU架构、浮点运算方式、指令集等参数。
程序下载和运行：
通过调试器下载：使用J-Link、ST-Link等调试器将程序烧录到Flash中。
通过串口下载：有些开发板支持通过串口的bootloader下载程序。
文件系统方式：如果有文件系统，可以通过网络、SD卡等方式拷贝到开发板然后执行。
启动运行过程：
硬件复位：开发板上电后CPU从复位向量开始执行。
bootloader引导：U-Boot或其他bootloader完成硬件初始化，加载我们的程序到内存。
程序执行：跳转到我们程序的入口地址开始执行，如果是裸机程序直接运行，如果有操作系统则作为任务或进程运行。
```
## 36.解释逻辑地址 线性地址 物理地址
```
逻辑地址（虚拟地址）：
程序中使用的地址，是程序员在代码中看到的地址，比如变量的地址、函数的地址等。这个地址是相对于程序自身的，不是真实的硬件地址。
每个程序都有自己的地址空间，两个程序可以使用相同的逻辑地址，但它们映射到不同的物理位置。
线性地址（在x86架构中）：
分段机制的产物，逻辑地址通过段寄存器和段描述符转换成线性地址。在现代系统中，通常使用平坦内存模型，线性地址就等于逻辑地址。
在ARM架构中：没有分段机制，所以逻辑地址直接对应线性地址。
物理地址：
真实的硬件内存地址，CPU最终访问内存时使用的地址，是内存条上实际的物理位置。
由内存管理单元MMU负责转换，将线性地址通过页表转换成物理地址。
地址转换过程：
第一步：程序使用逻辑地址访问内存。
第二步：MMU根据页表将逻辑地址转换成物理地址。
第三步：CPU使用物理地址访问实际的内存位置。
```
## 37.介绍linux的mmu
## 38.什么是嵌入式系统中的代码优化？
## 39.嵌入式系统中如何实现低延迟

## 41.如何实现动态内存分配？
## 42.cmake和makefile区别
## 43.linux根文件系统（busybox uclibc buildroot yocto）

## 44.数组越界有什么危害
## 45.熟悉哪些操作系统
## 46.栈泄露有什么危害

## 47.GPIO推挽和开漏输出的区别
## 48.ad采样位数代表什么，什么因素影响ADC精度和转换速率，有什么滤波算法
## 49.中断如何设置 中断中任务过多有什么危害

## 50.串口通信起始位如何判定，IIC总线仲裁？
## 51.设备偶发重启如何定位？（分析崩溃现场寄存器，通过jlink读取cfsr，检测堆栈溢出，mpu区域配置；电源完整性测量，示波器抓取跌落波形）
## 52.IIC从机无响应如何排查（逻辑分析仪捕获SCL/SDA波形，验证上拉电阻阻值，通常4.7ko，检查从设备地址配置，7/10位）

## 57.uart通信如何保证数据的正确性
## 58.TCP协议中涉及的大端序和小端序问题
## 59.中断处理函数如果需要返回一个值，应如何实现？

## 61.TCP和UDP相关API函数
## 62.IIC总线的特点，速率范围，硬件IIC和软件模拟IIC的主要区别
## 63.spi工作原理

## 64.如何判断一个链表是否存在环
## 67.裸机和freertos的区别
## 69.GDB常见命令和常用流程

## 70.RAII的核心概念和应用场景
## 72.搞崩程序如何解决
## 77.在嵌入式这个岗位中需要哪些核心能力 你自身有哪些和它匹配

## 78.C++
- C++特性 使用场景
- c++中的左值引用和指针的区别
- c++的内存分配机制是怎么样的
- mmu是什么 它如何将虚拟地址换为物理地址
- 智能指针理解
- 共享指针使用场景
- vector和list区别
- vector容器的底层实现机制以及优势所在
- vector扩容会按照什么数量级别进行扩容
- 扩容后访问vector下标容易造成迭代器的失效，怎么解决
- 对于vector这个对象，是放在堆上还是栈上

## 79.操作系统
- 进程间通讯方式
- 消息队列和共享内存详解
- 如何避免访问共享内存的时候出现操作不原子性的问题
- linux内存管理 当内存不够的时候 需要去申请内存 这时候系统会怎么做

## 80.说明flash rom ram和eeprom在嵌入式系统的不同应用场景
## 81.嵌入式系统中，信号处理函数通常采用哪些实现方式
## 82.于传统PID相比 现代控制算法如mpc 自适应控制有哪些优势，在嵌入式平台实现时要考虑哪些性能因素
## 83.设备树在嵌入式系统中有什么作用



## 73.介绍实习中的工作内容，遇到的技术方面的挑战
## 74.哪些功能遇到了多线程，开发过程中遇到的问题，合作经历，合作中遇到的问题 如何处理以及下一步改善
## 75.项目中某个技术的实现过程，优化达到的效果，指标体现
## 76.项目中有用不同的方案去对比吗 为什么选择这种方案
## 71.设计模式，选择一个项目中用到的设计模式详细介绍
## 65.项目上主要遇到的技术难点
## 28.项目中应用了PID控制和外部中断，要求说明PID参数的初始化方法以及外部中断的具体应用场景
## 24.你的项目中使用过哪些复杂的项目结构？
## 16.介绍你项目中的串口使用方法，（涉及DMA，缓冲区，中断等）
## 19.请介绍你实现低功耗的方法？若想从超低功耗的standby模式唤醒系统，应如何操作
## 30.I2C是硬件实现还是软件模拟，原因是什么
## 60.平时如何进行技术学习？如何总结并汇报一个项目
## 20.半结构化
- 对本公司了解
- 行业现状和发展前景看待
- 近期职业发展规划